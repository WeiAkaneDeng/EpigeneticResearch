#' @title Elastic net using summary statistics
#' @description Coordinate descent algorithm to solve: 
#' 0.5 x'X'Xx - x'b + lambda1 ||x||_1 + 0.5 lambda2 ||x||_2^2
#' Function to get elastic net solutions given X, a reference panel, and
#' b, regression coefficients
#' @keywords internal
elnetR <- function(lambda1, lambda2=0, X, b, thr=1e-4,
                     trace=0, maxiter=10000, 
                   blocks=NULL, 
                   x=NULL) {
  stopifnot(length(b) == ncol(X))
  diag <- colSums(X^2)

  if(length(lambda2) > 1) {
    nlambda2 <- length(lambda2)
    for(i in 1:nlambda2) {
      result <- elnetR(lambda1, lambda2[i], X, b, thr,
                         trace, maxiter, x)
      result <- list(fit=result, lambda2=lambda2[i])
      if(i == 1) Result <- rep(result, nlambda2) else
        Result[i] <- result

    }
    return(Result)
  }

  order <- order(lambda1, decreasing = T)
  lambda1a <- lambda1[order]
  conv <- lambda1a * NA
  len <- length(b)
  beta <- matrix(NA, len, length(lambda1))
  pred <- matrix(NA, nrow(X), length(lambda1))
  loss <- rep(NA, length(lambda1))
  fbeta <- loss

  if(is.null(x)) x <- b * 0.0 else {
    stopifnot(length(x) == len)
    x <- x + 0.0 # Making sure R creates a copy...
  }

  if(is.null(blocks)) {
    Blocks <- list(startvec=0, endvec=len - 1)
  } else {
    Blocks <- parseblocks(blocks)
    stopifnot(max(Blocks$endvec)==len - 1)
  }
  
  X <- as.matrix(X)
  yhat <- as.vector(X %*% x)

  for(i in 1:length(lambda1a)) {
    if(trace > 0) cat("lambda1: ", lambda1a[i], "\n")
    conv[i] <- repelnet(lambda1a[i], lambda2, diag, X, b,thr,x,yhat, trace-1,maxiter,
                        Blocks$startvec, Blocks$endvec)
    if(conv[i] != 1) stop("Not converging...")

    beta[,i] <- x
    pred[,i] <- yhat
    loss[i] <- sum(yhat^2) - 2* sum(b * x)
    fbeta[i] <- loss[i] + 2* sum(abs(x))*lambda1a[i] + sum(x^2)*lambda2
  }


  conv[order] <- conv
  beta[,order] <- beta
  pred[,order] <- pred
  loss[order] <- loss
  fbeta[order] <- fbeta

  return(list(lambda1=lambda1, lambda2=lambda2, beta=beta, conv=conv, pred=pred, loss=loss, fbeta=fbeta))

}


# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Count number of lines in a text file
#' 
#' @param fileName Name of file
#' @keywords internal
#' 
countlines <- function(fileName) {
    .Call('_lassosum_countlines', PACKAGE = 'lassosum', fileName)
}

#' Multiply genotypeMatrix by a matrix
#' 
#' @param fileName location of bam file
#' @param N number of subjects 
#' @param P number of positions 
#' @param input the matrix
#' @param col_skip_pos which variants should we skip
#' @param col_skip which variants should we skip
#' @param keepbytes which bytes to keep
#' @param keepoffset what is the offset
#' @return an armadillo genotype matrix 
#' @keywords internal
#' 
multiBed3 <- function(fileName, N, P, input, col_skip_pos, col_skip, keepbytes, keepoffset, trace) {
    .Call('_lassosum_multiBed3', PACKAGE = 'lassosum', fileName, N, P, input, col_skip_pos, col_skip, keepbytes, keepoffset, trace)
}

#' Multiply genotypeMatrix by a matrix (sparse)
#' 
#' @param fileName location of bam file
#' @param N number of subjects 
#' @param P number of positions 
#' @param input the matrix
#' @param col_skip_pos which variants should we skip
#' @param col_skip which variants should we skip
#' @param keepbytes which bytes to keep
#' @param keepoffset what is the offset
#' @return an armadillo genotype matrix 
#' @keywords internal
#' 
multiBed3sp <- function(fileName, N, P, beta, nonzeros, colpos, ncol, col_skip_pos, col_skip, keepbytes, keepoffset, trace) {
    .Call('_lassosum_multiBed3sp', PACKAGE = 'lassosum', fileName, N, P, beta, nonzeros, colpos, ncol, col_skip_pos, col_skip, keepbytes, keepoffset, trace)
}

#' Performs elnet
#'
#' @param lambda1 lambda
#' @param lambda2 lambda
#' @param X genotype Matrix
#' @param r correlations
#' @param x beta coef
#' @param thr threshold 
#' @param yhat A vector
#' @param trace if >1 displays the current iteration
#' @param maxiter maximal number of iterations
#' @return conv
#' @keywords internal
#' 
elnet <- function(lambda1, lambda2, diag, X, r, thr, x, yhat, trace, maxiter) {
    .Call('_lassosum_elnet', PACKAGE = 'lassosum', lambda1, lambda2, diag, X, r, thr, x, yhat, trace, maxiter)
}

repelnet <- function(lambda1, lambda2, diag, X, r, thr, x, yhat, trace, maxiter, startvec, endvec) {
    .Call('_lassosum_repelnet', PACKAGE = 'lassosum', lambda1, lambda2, diag, X, r, thr, x, yhat, trace, maxiter, startvec, endvec)
}

#' imports genotypeMatrix
#' 
#' @param fileName location of bam file
#' @param N number of subjects 
#' @param P number of positions 
#' @param col_skip_pos which variants should we skip
#' @param col_skip which variants should we skip
#' @param keepbytes which bytes to keep
#' @param keepoffset what is the offset
#' @return an armadillo genotype matrix 
#' @keywords internal
#' 
genotypeMatrix <- function(fileName, N, P, col_skip_pos, col_skip, keepbytes, keepoffset, fillmissing) {
    .Call('_lassosum_genotypeMatrix', PACKAGE = 'lassosum', fileName, N, P, col_skip_pos, col_skip, keepbytes, keepoffset, fillmissing)
}

#' normalize genotype matrix
#' 
#' @param genotypes a armadillo genotype matrix
#' @return standard deviation
#' @keywords internal
#' 
normalize <- function(genotypes) {
    .Call('_lassosum_normalize', PACKAGE = 'lassosum', genotypes)
}

#' Runs elnet with various parameters
#' 
#' @param lambda1 a vector of lambdas (lambda2 is 0)
#' @param fileName the file name of the reference panel
#' @param r a vector of correlations
#' @param N number of subjects
#' @param P number of position in reference file
#' @param col_skip_posR which variants should we skip
#' @param col_skipR which variants should we skip
#' @param keepbytesR required to read the PLINK file
#' @param keepoffsetR required to read the PLINK file
#' @param thr threshold
#' @param x a numeric vector of beta coefficients
#' @param trace if >1 displays the current iteration
#' @param maxiter maximal number of iterations
#' @param Constant a constant to multiply the standardized genotype matrix
#' @return a list of results
#' @keywords internal
#'  
runElnet <- function(lambda, shrink, fileName, r, N, P, col_skip_pos, col_skip, keepbytes, keepoffset, thr, x, trace, maxiter, startvec, endvec) {
    .Call('_lassosum_runElnet', PACKAGE = 'lassosum', lambda, shrink, fileName, r, N, P, col_skip_pos, col_skip, keepbytes, keepoffset, thr, x, trace, maxiter, startvec, endvec)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('_lassosum_RcppExport_registerCCallable', PACKAGE = 'lassosum')
})